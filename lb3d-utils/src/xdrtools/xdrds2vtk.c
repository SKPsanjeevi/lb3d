/* Take a 3D XDR-double file, and write a subvolume of it out in VTK format */

#include <stdio.h>
#include <stdlib.h>
#include <rpc/rpc.h>

#include <assert.h>

int main(int argc, char *argv[])
{
	FILE *infile,*outfile;
	char *infname,*outfname;
	int x,y,z;
	int inx,iny,inz;
	int outx,outy,outz;
	XDR xdrs;
#ifdef SGL
	float *buf,*p;
	float junkdoub;
#else
	double *buf,*p;
	double junkdoub;
#endif

	if (argc!=9) {
		fprintf(stderr,
			"Usage: %s infile nx ny nx outfile nx ny nz\n",
			argv[0]);
		return -1;
	}

	infname = argv[1];
	inx = atoi(argv[2]);
	iny = atoi(argv[3]);
	inz = atoi(argv[4]);
	outfname = argv[5];
	outx = atoi(argv[6]);
	outy = atoi(argv[7]);
	outz = atoi(argv[8]);

	/* Sanity check arguments */

	if (
		(inx<0) || (iny<0) || (inz<0) ||
		(outx<0) || (outy<0) || (outz<0) ||
		(inx<outx) || (iny<outy) || (inz<outz)
	) {
		fprintf(stderr,"Bad sizes\n");
		return -1;
	}

	/* Make buffer large enough to contain downsized dataset */

#ifdef SGL
	if (NULL==(buf=malloc(sizeof(float)*outx*outy*outz))) {
		perror("malloc()");
		return -1;
	}
#else
	if (NULL==(buf=malloc(sizeof(double)*outx*outy*outz))) {
		perror("malloc()");
		return -1;
	}
#endif

	if (NULL==(infile=fopen(infname,"rb"))) {
		perror("fopen()");
		free(buf);
		return -1;
	}
	if (NULL==(outfile=fopen(outfname,"wb"))) {
		perror("fopen()");
		free(buf);
		fclose(infile);
		return -1;
	}

	/* Start speaking XDR */

	xdrstdio_create(&xdrs,infile,XDR_DECODE);

	/* Read the file in: use Fortan ordering */

	p=buf;
	for (z=0;z<outz;z++) {
		for (y=0;y<outy;y++) {
			for (x=0;x<outx;x++) {
#ifdef SGL
				if (1!=xdr_float(&xdrs,p++)) {
					fprintf(stderr,
					"xdr_float() 1 failed at %d %d %d\n",
					x,y,z);
				}
#else
				if (1!=xdr_double(&xdrs,p++)) {
					fprintf(stderr,
					"xdr_double() 1 failed at %d %d %d\n",
					x,y,z);
				}
#endif
			}
			/* Skip the rest of the X block */
			assert(x==outx);
			for (;x<inx;x++) {
#ifdef SGL
				if (1!=xdr_float(&xdrs,&junkdoub)) {
					fprintf(stderr,
					"xdr_float() 2 failed at %d %d %d\n",
					x,y,z);
				}
#else
				if (1!=xdr_double(&xdrs,&junkdoub)) {
					fprintf(stderr,
					"xdr_double() 2 failed at %d %d %d\n",
					x,y,z);
				}
#endif
			}
		}
		/* Skip the rest of the Y block */
		assert(y==outy);
		for (;y<iny;y++) {
			for (x=0;x<inx;x++) {
#ifdef SGL
				if (1!=xdr_float(&xdrs,&junkdoub)) {
					fprintf(stderr,
					"xdr_float() 3 failed at %d %d %d\n",
					x,y,z);
				}
#else
				if (1!=xdr_double(&xdrs,&junkdoub)) {
					fprintf(stderr,
					"xdr_double() 3 failed at %d %d %d\n",
					x,y,z);
				}
#endif
			}
		}
	}
	xdr_destroy(&xdrs);
	fclose(infile);

	/* XDR data has been read into buffer. */

	/* Now write out VTK file */

	fprintf(outfile,"# vtk DataFile Version 2.0\n"
			"Generated by xdrds2vtk\n"
			"BINARY\n");
	fprintf(outfile,"DATASET STRUCTURED_POINTS\n");
	fprintf(outfile,"DIMENSIONS %d %d %d\n",outx,outy,outz);
	fprintf(outfile,"SPACING 1 1 1\n");
	fprintf(outfile,"ORIGIN 0 0 0\n");
	fprintf(outfile,"POINT_DATA %d\n",outx*outy*outz);
#ifdef SGL
	fprintf(outfile,"SCALARS scalars float\n");
#else
	fprintf(outfile,"SCALARS scalars double\n");
#endif
	fprintf(outfile,"LOOKUP_TABLE default\n");

#ifdef SGL
	fwrite(buf,sizeof(float),outx*outy*outz,outfile);
#else
	fwrite(buf,sizeof(double),outx*outy*outz,outfile);
#endif

	fclose(outfile);
	free(buf);
	return 0;
				
}
