/* Compile me with:
 * gcc -Wall -pedantic -O6 -o gi \
 * glutiso.c mcubes.c mcubes_tables.c vol3df.c vol3d.c \
 * -lglut -lm -lhdf5
 *
 *
 * 2002-2004 Jonathan Chin <jon-src-glutiso.c@earth.li>
 */


/*
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>


#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>

#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif

#ifdef HAVE_PNG
#include <png.h>
#endif

#include "vol3df.h"
#include "growarr.h"
#include "isosurface.h"
#include "quat.h"

#include "dirscan.h"

#include "screenshot.h"


#define ARENASIZE 100.0
const int dtime=5;

struct window {
    int id;
    int screenx,screeny;
    GLfloat sphererad; /* Radius of trackball sphere */
    int clickx,clicky;
    int leftState,middleState,rightState;
    GLuint meshList;

    int mousex,mousey;          /* Mouse status */
    int leftbutdown;
    int rightbutdown;
    int midbutdown;
    int bx,by;

};

struct window window;
struct window leftWindow,rightWindow;

long int mstime=0; /* time in ms from when spin was started */

struct mcubes_state **mcubesList=NULL;
int winPosX=0;
int winPosY=0;
int rightWindowOffset=0;

char **fileNames;
int debugMode = 0;
int stereoFlag=0;
int timeFrameFlag=0;
int windowedStereoFlag=0;
int wrapMeshNoFlag=0,spinFlag=0,fogFlag=0,axesFlag=0,outlineFlag=0;
int cuberilleFlag=0,vertexLabelFlag=0,triangleLabelFlag=0;
int specularFlag=0,orthoFlag=0,meshOutlineFlag=0, debugOverlayFlag=0;
int surfaceFlag=1;
int scalarCurvatureFlag=0;
int gaussianCurvatureFlag=0;
int normalizeScalarFlag=0;

int loadNewestFlag=0;
time_t newestTime=0;
time_t minAge=3;

char *newestPrefix=NULL;
unsigned int checkFilesInterval = 1000; /* milliseconds between checks */

float fov=60.0;
float globalThreshold=0.0;
float globalColScale=1.0;
void (*globalColMapFunc)(float,struct vol3df_stats *,GLfloat *) = NULL;
float globalFogDensity=0.01;


int labelflag=0;
int colVolFlag=0;
int colouredFlag=0;
int fullscreenflag=0;
int vNormalsFlag=1; /* Calculate vertex normals by default */
int perspectiveFlag=1; /* Set to 1 for perspective projection */
GLfloat eyeSize=0.15;


int currentMeshNo=0,nMeshes=0;

/* Approximate height in GL units of the characters generated by
 * glutStrokeCharacter(GLUT_STROKE_ROMAN,...);
 * See section 10.3 of the GLUT spec.
 */

const float stroke_height = 119.05+33.33;

/*********** globals for main code ************/

const GLfloat nearclip=0.1;
const GLfloat farclip=1024.0;

/* background colour; default is black */
GLclampf bgColour[3] = { 0.0,0.0,0.0 };
/* Default outline colour is black*/
GLclampf outline_colour[3] = { 0.0,0.0,0.0 };
GLfloat innerColour[4] = { 1.0,0.0,0.0,1.0 };
GLfloat outerColour[4] = { 0.0,0.0,1.0,1.0 };





int glinit=0; /* Set to 1 once GL has been set up */
unsigned int frameno=0;

/* Quaternion for global orientation */
quat_t orquat;

GLfloat geomx=0,geomy=0,geomz=-200;

/* Routines to set bits of GL state consistently across windows */

#define ALL_WINDOWS(glstuff) \
        if (windowedStereoFlag) { \
        GLuint currID; \
        currID=glutGetWindow(); \
 \
        glutSetWindow(leftWindow.id); \
        glstuff \
        glutSetWindow(rightWindow.id); \
        glstuff \
 \
        glutSetWindow(currID); \
    } else { \
        glstuff \
    } 




/* Like glutStrokeCharacter, but takes a pointer to null-term string */
void StrokeString(void *font, char *p)
{
        int c;

        while ((c=*p++)) {
                glutStrokeCharacter(font,c);
        }
}


/* Convert HSV colour specification to RGB.
 * Adapted from Foley et al, "Introduction to Computer Graphics",
 * 1990 Addison-Wesley, p415-416
 */
static void hsv2rgb(GLfloat *r,GLfloat *g,GLfloat *b,
	GLfloat h,GLfloat s,GLfloat v)
{
	GLfloat f,p,q,t;
	int i;

	if (0.0==s) {	/* Colour in black-and-white centre line */
		*r=*g=*b=v;
		return;
	}
	while (h>360.0) {
		h-=360.0;
	}
	/* h is now below 360 */
	h/=60.0;

	i=floor(h);	/* h now in [0,6] */
	f=h-i; /* f is fractional part of h */
	p=v*(1-s);
	q=v*(1-s*f);
	t=v*(1-s*(1-f));

	switch(i) {
		case 0:
			*r=v; *g=t; *b=p; break;
		case 1:
			*r=q; *g=v; *b=p; break;
		case 2:
			*r=p; *g=v; *b=t; break;
		case 3:
			*r=p; *g=q; *b=v; break;
		case 4:
			*r=t; *g=p; *b=v; break;
		case 5:
			*r=v; *g=p; *b=q; break;
	}
	
}

/* Return a pointer to the current window object.
 * Works by finding the current glut Window ID, and comparing to
 * each window struct in turn..
 */
struct window *getWindow(void)
{
    GLuint currID;

    currID = glutGetWindow();
    if (windowedStereoFlag) {
        if (currID == leftWindow.id) {
            return &leftWindow;
        } else if (currID == rightWindow.id) {
            return &rightWindow;
        } else {
            fprintf(stderr,"Unknown window ID %d!\n",(int)currID);
            fflush(stderr);
            exit(-1);
        }
    } else {
        if (currID != window.id) {
            fprintf(stderr,"Warning: unknown window ID %d!\n",(int)currID);
            fprintf(stderr,"Main window is %u\n",window.id);
            fflush(stderr);
        }
        return &window;
    }
}

GLuint getMeshList(void)
{
    return getWindow()->meshList;
}

/* Post a Redisplay event to all windows */

void allPostRedisplay(void)
{
    if (windowedStereoFlag) {
        GLuint currID;
        currID = glutGetWindow();
        glutSetWindow(leftWindow.id);
        glutPostRedisplay();
        glutSetWindow(rightWindow.id);
        glutPostRedisplay();
        glutSetWindow(currID);
    } else {
        glutPostRedisplay();
    }
}

void hueColourMap(float phi, struct vol3df_stats *stats,GLfloat *col) {
        float phimin,phimax;

        phimin = stats->min;
        phimax = stats->max;
        phi = (phi-phimin)/(phimax-phimin);

        /* 0.0 <= phi <= 1.0 */


        hsv2rgb(col,col+1,col+2,phi*360.0,0.9,0.9);


        return;

}

void linearColourMap(float phi, struct vol3df_stats *stats,GLfloat *col) {
        GLfloat r,g,b;
        float phimin,phimax;
        float r0,g0,b0,r1,g1,b1;

        phimin = stats->min;
        phimax = stats->max;
        phi = (phi-phimin)/(phimax-phimin);


        r0=1.0; g0=0.0; b0=0.0;
        r1=0.0; g1=0.0; b1=1.0;

        r = r0 + phi*(r1-r0);
        g = g0 + phi*(g1-g0);
        b = b0 + phi*(b1-b0);

        col[0]=r;
        col[1]=g;
        col[2]=b;
        return;

}

void cubicColourMap(float phi, struct vol3df_stats *stats,GLfloat *col) {
        GLfloat r,g,b;
        float phimin,phimax;
        float r0,g0,b0,r1,g1,b1;

        phimin = stats->min;
        phimax = stats->max;
        phi = (phi-phimin)/(phimax-phimin);

        phi = phi*phi*phi;

        r0=1.0; g0=0.0; b0=0.0;
        r1=0.0; g1=0.0; b1=1.0;

        r = r0 + phi*(r1-r0);
        g = g0 + phi*(g1-g0);
        b = b0 + phi*(b1-b0);

        col[0]=r;
        col[1]=g;
        col[2]=b;
        return;

}

/********************* Main code *********************/


void toggleSpecular(void)
{
        GLfloat specular[]={1.0,1.0,1.0,1.0};
        GLfloat zero[]={0.0,0.0,0.0,0.0};

        if ((specularFlag = 1-specularFlag)) {
                ALL_WINDOWS(
                        glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,specular);
                        )
        } else {
            ALL_WINDOWS(
                glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,zero);
                    )
        }
        printf("Specular lighlights %s.\n", specularFlag ? "on" : "off" );

        allPostRedisplay();
}

void toggleSurface(void)
{
    if ((surfaceFlag = 1-surfaceFlag)) {
        ALL_WINDOWS(
                glEnable(GL_FOG);
        )
    } else {
        ALL_WINDOWS(
                glDisable(GL_FOG);
        )
    }
    printf("Isosurface rendering %s.\n", surfaceFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleFog(void)
{
    if ((fogFlag = 1-fogFlag)) {
        ALL_WINDOWS(glEnable(GL_FOG);)
    } else {
        ALL_WINDOWS(glDisable(GL_FOG);)
    }
    printf("Fogging %s.\n", fogFlag ? "on" : "off" );

    allPostRedisplay();
}



const float globalFogRatio=1.1;

void increaseFog(void)
{
    globalFogDensity*=globalFogRatio;
    printf("Fog density %f\n",globalFogDensity);
    ALL_WINDOWS(glFogf(GL_FOG_DENSITY,globalFogDensity);)
    allPostRedisplay();
}
void decreaseFog(void)
{
    globalFogDensity/=globalFogRatio;
    printf("Fog density %f\n",globalFogDensity);
    ALL_WINDOWS(glFogf(GL_FOG_DENSITY,globalFogDensity);)
    allPostRedisplay();
}


void toggleAxes(void)
{
    axesFlag = 1 - axesFlag;
    printf("Axes %s.\n", axesFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleOutline(void)
{
    outlineFlag = 1 - outlineFlag;
    printf("Outline %s.\n", outlineFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleCuberille(void)
{
    cuberilleFlag = 1 - cuberilleFlag;
    printf("Cuberille %s.\n", cuberilleFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleVertexLabels(void)
{
    vertexLabelFlag = 1 - vertexLabelFlag;
    printf("Vertex labels %s.\n", vertexLabelFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleMeshOutline(void)
{
    meshOutlineFlag = 1 - meshOutlineFlag;
    printf("Mesh outline %s.\n", meshOutlineFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleDebugOverlay(void)
{
    debugOverlayFlag = 1 - debugOverlayFlag;
    printf("Debugging overlay %s.\n", debugOverlayFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleOrtho(void)
{
    orthoFlag = 1 - orthoFlag;
    printf("Orthographic projection %s.\n", orthoFlag ? "on" : "off" );

    allPostRedisplay();
}

void toggleTriangleLabels(void)
{
    triangleLabelFlag = 1 - triangleLabelFlag;
    printf("Triangle labels %s.\n", triangleLabelFlag ? "on" : "off" );

    allPostRedisplay();
}

void mcubes_draw(struct mcubes_state *mc,
        void (*colfunc)(float,struct vol3df_stats *,GLfloat *)
    ) {
    int i;
    unsigned int ntriangles;
    float scalarA,scalarB,scalarC;
    GLfloat colourA[4] = { 0, 0, 1, 1 };
    GLfloat colourB[4] = { 0, 0, 1, 1 };
    GLfloat colourC[4] = { 0, 0, 1, 1 };

    ntriangles = growarr_nitems(mc->triangle);
    glBegin(GL_TRIANGLES);
    for (i=0;i<ntriangles;i++) {
        struct vector va,vb,vc;
        struct vector na,nb,nc;
        struct tri tri;

        tri= *(struct tri *)   growarr_get_nth(mc->triangle,i);
        va = *(struct vector *)growarr_get_nth(mc->vertex,tri.a);
        vb = *(struct vector *)growarr_get_nth(mc->vertex,tri.b);
        vc = *(struct vector *)growarr_get_nth(mc->vertex,tri.c);


        if (NULL!=mc->scalar) {
            scalarA = *(float *)growarr_get_nth(mc->scalar,tri.a);
            scalarB = *(float *)growarr_get_nth(mc->scalar,tri.b);
            scalarC = *(float *)growarr_get_nth(mc->scalar,tri.c);
            colfunc(globalColScale*scalarA,mc->scalarstats,colourA);
            colfunc(globalColScale*scalarB,mc->scalarstats,colourB);
            colfunc(globalColScale*scalarC,mc->scalarstats,colourC);
        }

        if (NULL==mc->normal) {
            struct vector norm;
            /* No vertex normals, so roll our own. */
            norm=vector_cross(vector_sub(vb,va),vector_sub(vc,va));
            glNormal3f(norm.x,norm.y,norm.z);

            if (NULL==mc->scalar) {
                glVertex3f(va.x,va.y,va.z);
                glVertex3f(vb.x,vb.y,vb.z);
                glVertex3f(vc.x,vc.y,vc.z);
            } else {
                glColor4fv(colourA);
                glVertex3f(va.x,va.y,va.z);
                glColor4fv(colourB);
                glVertex3f(vb.x,vb.y,vb.z);
                glColor4fv(colourC);
                glVertex3f(vc.x,vc.y,vc.z);
            }
        } else {
            if (NULL==mc->scalar) {
                na=*(struct vector *)growarr_get_nth(mc->normal,tri.a);
                nb=*(struct vector *)growarr_get_nth(mc->normal,tri.b);
                nc=*(struct vector *)growarr_get_nth(mc->normal,tri.c);
                glNormal3f(na.x,na.y,na.z);
                glVertex3f(va.x,va.y,va.z);
                glNormal3f(nb.x,nb.y,nb.z);
                glVertex3f(vb.x,vb.y,vb.z);
                glNormal3f(nc.x,nc.y,nc.z);
                glVertex3f(vc.x,vc.y,vc.z);
            } else {
                na=*(struct vector *)growarr_get_nth(mc->normal,tri.a);
                nb=*(struct vector *)growarr_get_nth(mc->normal,tri.b);
                nc=*(struct vector *)growarr_get_nth(mc->normal,tri.c);
                glNormal3f(na.x,na.y,na.z);
                glColor4fv(colourA);
                glVertex3f(va.x,va.y,va.z);
                glNormal3f(nb.x,nb.y,nb.z);
                glColor4fv(colourB);
                glVertex3f(vb.x,vb.y,vb.z);
                glNormal3f(nc.x,nc.y,nc.z);
                glColor4fv(colourC);
                glVertex3f(vc.x,vc.y,vc.z);
            }
        }
    }
    glEnd();
}


void initGL()
{
    GLfloat ambient[]={1.0,1.0,1.0,1.0};
    GLfloat shininess[]={50};
    GLfloat position[]={1,1,1,1};
    GLfloat fogColor[]={0.0,0.0,0.0,1.0};



    glShadeModel(GL_SMOOTH);

    glClearColor(bgColour[0],bgColour[1],bgColour[2],0.5);
    glClearDepth(1.0);

    glDepthFunc(GL_LESS);
    glDepthMask(GL_TRUE);
    glEnable(GL_DEPTH_TEST);

    glCullFace(GL_BACK);
    glDisable(GL_CULL_FACE);

    glDisable(GL_TEXTURE_2D);
    glEnable(GL_NORMALIZE);

    /* Lighting */

    glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE,ambient);
    glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shininess);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,1);
    glLightfv(GL_LIGHT0,GL_POSITION,position);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);


    /* Colour and material */

    glEnable(GL_COLOR_MATERIAL);

    glColorMaterial(GL_BACK,GL_AMBIENT_AND_DIFFUSE);
    glColor3fv(innerColour);
    glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
    glColor3fv(outerColour);
    glEnable(GL_LINE_SMOOTH);
    glDisable(GL_BLEND);
    glLineWidth(3.0);

    /* Fogging */

    glFogi(GL_FOG_MODE,GL_EXP2);
    glFogfv(GL_FOG_COLOR,fogColor);
    glFogf(GL_FOG_DENSITY,globalFogDensity);
    glFogf(GL_FOG_START,1);
    glFogf(GL_FOG_END,64.0);
    glHint(GL_FOG,GL_NICEST);
    glDisable(GL_FOG);

    /* polygon offset, in case mesh outline is drawn */

    glPolygonOffset(1.0,1.0);
    glEnable(GL_POLYGON_OFFSET_FILL);

    glHint(GL_POINT_SMOOTH_HINT,GL_NICEST);

    glinit=1;
}

/* argument is inverse of viewing transformation matrix */
void drawAxes(GLfloat *mi)
{
    const GLfloat axiswidth=3.0;
    const GLfloat xcolor[4] = { 1.0, 0.0, 0.0, 1.0 };
    const GLfloat ycolor[4] = { 0.0, 1.0, 0.0, 1.0 };
    const GLfloat zcolor[4] = { 0.0, 0.0, 1.0, 1.0 };
    GLfloat alscale=1.0; /* axis label scale */
    GLfloat vx,vy,vz;

    vx = mcubesList[currentMeshNo]->nx;
    vy = mcubesList[currentMeshNo]->ny;
    vz = mcubesList[currentMeshNo]->nz;

    alscale=0.01;

    glPushMatrix();
        glTranslatef(-0.5*vx,-0.5*vy,-0.5*vz);

        glPushMatrix();
            glColor4fv(xcolor);
            glTranslatef(vx,0,0);
            glMultMatrixf(mi);
            glScalef(alscale,alscale,alscale);
		    glutStrokeCharacter(GLUT_STROKE_ROMAN,'X');
        glPopMatrix();

        glPushMatrix();
            glColor4fv(ycolor);
            glTranslatef(0,vy,0);
            glMultMatrixf(mi);
            glScalef(alscale,alscale,alscale);
		    glutStrokeCharacter(GLUT_STROKE_ROMAN,'Y');
        glPopMatrix();

        glPushMatrix();
            glColor4fv(zcolor);
            glTranslatef(0,0,vz);
            glMultMatrixf(mi);
            glScalef(alscale,alscale,alscale);
		    glutStrokeCharacter(GLUT_STROKE_ROMAN,'Z');
        glPopMatrix();

        glScalef(vx,vy,vz);
        glLineWidth(axiswidth);
        glBegin(GL_LINES);
            glColor4fv(xcolor);
            glVertex3f(0,0,0);
            glVertex3f(1,0,0);

            glColor4fv(ycolor);
            glVertex3f(0,0,0);
            glVertex3f(0,1,0);

            glColor4fv(zcolor);
            glVertex3f(0,0,0);
            glVertex3f(0,0,1);
        glEnd();

    glPopMatrix();
}

void drawCuberille(void)
{
    int nx,ny,nz;
    int x,y,z;

    nx = mcubesList[currentMeshNo]->nx;
    ny = mcubesList[currentMeshNo]->ny;
    nz = mcubesList[currentMeshNo]->nz;


    glPushMatrix();
        glTranslatef(-0.5*nx,-0.5*ny,-0.5*nz);

        glColor3f(1,0,1);
        glBegin(GL_LINES);
                for (y=0;y<=ny;y++) {
                for (x=0;x<=nx;x++) {
                        glVertex3f(x,y,0); glVertex3f(x,y,nz);
                }}
                for (z=0;z<=nz;z++) {
                for (x=0;x<=nx;x++) {
                        glVertex3f(x,0,z); glVertex3f(x,ny,z);
                }}
                for (y=0;y<=ny;y++) {
                for (z=0;z<=nz;z++) {
                        glVertex3f(0,y,z); glVertex3f(nx,y,z);
                }}
        glEnd();
    glPopMatrix();
}

void drawMeshOutline(void)
{
    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
    glPushMatrix();
        glTranslatef(
            -0.5*mcubesList[currentMeshNo]->nx,
            -0.5*mcubesList[currentMeshNo]->ny,
            -0.5*mcubesList[currentMeshNo]->nz
        );

        glCallList(getMeshList()+currentMeshNo);

    glPopMatrix();
    glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
}

/* This is a general-purpose bit of code used to highlight
 * areas of mesh to be examined for debugging purposes.
 */
void drawDebugOverlay(void)
{
    int nPoints=8;
    GLfloat debugPoints[8][3] = {
{3.11586189,20.00000000,0.00000000},
{3.11586189,20.00000000,0.00000000},
{3.79564142,19.00000000,63.00000000},
{3.79564142,19.00000000,63.00000000},
{3.00000000,19.65431023,63.00000000},
{4.00000000,19.36915588,63.00000000},
{3.54621768,20.00000000,63.00000000},
{3.54621768,20.00000000,63.00000000}
    };
    int i;
    int vnx,vny,vnz;

    vnx = mcubesList[currentMeshNo]->nx;
    vny = mcubesList[currentMeshNo]->ny;
    vnz = mcubesList[currentMeshNo]->nz;
    
    glPushMatrix();
        glTranslatef(-vnx/2,-vny/2,-vnz/2);
        glColor4f(1,1,0,1);
        glPointSize(5.0);
        glBegin(GL_POINTS);
            for (i=0;i<nPoints;i++) {
                glVertex3fv(debugPoints[i]);
            }
        glEnd();
    glPopMatrix();

}

void drawOutline(void)
{
        glPushMatrix();
                glScalef(
                        mcubesList[currentMeshNo]->nx,
                        mcubesList[currentMeshNo]->ny,
                        mcubesList[currentMeshNo]->nz
                        );
                glColor4f(0,1,0,1);
                glutWireCube(1.0);
        glPopMatrix();
}

void drawVertexLabels(GLfloat *mi)
{

    GLfloat scale=0.0005;
    int i,nvertices;
    char vname[5];
    int vnx,vny,vnz;

    vnx = mcubesList[currentMeshNo]->nx;
    vny = mcubesList[currentMeshNo]->ny;
    vnz = mcubesList[currentMeshNo]->nz;


    nvertices = growarr_nitems(mcubesList[currentMeshNo]->vertex);
    if (nvertices>9999) {
        fprintf(stderr,"label_vertices: too many vertices.\n");
        toggleVertexLabels();
        return;
    }

    glPushMatrix();

    glColor3f(0,1,0);
        glTranslatef(-vnx/2,-vny/2,-vnz/2);
        for (i=0;i<nvertices;i++) {
            struct vector vert;
            vert = *(struct vector *)
                growarr_get_nth(mcubesList[currentMeshNo]->vertex,i);
            snprintf(vname,5,"%04d",i);
            glPushMatrix();
                glTranslatef(vert.x,vert.y,vert.z);
                glMultMatrixf(mi);
                glScalef(scale,scale,scale);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[0]);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[1]);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[2]);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[3]);
            glPopMatrix();
        }

    glPopMatrix();
}

void drawTriangleLabels(GLfloat *mi)
{

    GLfloat scale=0.0008;
    int i,ntris;
    char vname[5];
    struct mcubes_state *mesh=NULL;
    int vnx,vny,vnz;

    vnx = mcubesList[currentMeshNo]->nx;
    vny = mcubesList[currentMeshNo]->ny;
    vnz = mcubesList[currentMeshNo]->nz;

    mesh = mcubesList[currentMeshNo];


    ntris = growarr_nitems(mesh->triangle);
    if (ntris>9999) {
        fprintf(stderr,"label_triangles: too many triangles.\n");
        toggleTriangleLabels();
        return;
    }

    glPushMatrix();
        glColor3f(0,1,1);
        glTranslatef(-vnx/2,-vny/2,-vnz/2);
        for (i=0;i<ntris;i++) {
            struct vector va,vb,vc,centroid;
            struct tri t;
            t = *(struct tri *)growarr_get_nth(mesh->triangle,i);
            va = *(struct vector *)growarr_get_nth(mesh->vertex,t.a);
            vb = *(struct vector *)growarr_get_nth(mesh->vertex,t.b);
            vc = *(struct vector *)growarr_get_nth(mesh->vertex,t.c);

            centroid = vector_add(va,vb);
            centroid = vector_add(centroid,vc);
            centroid = vector_scale(centroid,1.0/3.0);

            snprintf(vname,5,"%04d",i);
            glPushMatrix();
                glTranslatef(centroid.x,centroid.y,centroid.z);
                glMultMatrixf(mi);
                glScalef(scale,scale,scale);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[0]);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[1]);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[2]);
                glutStrokeCharacter(GLUT_STROKE_ROMAN,vname[3]);
            glPopMatrix();
        }
    glPopMatrix();
}

/* Run through all the mcubes objects, find the global max and min.
 * Assume the distribution of the scalar is symmetric about 0, and
 * set all of the scalar stats objects to have max and min equal to
 * +/- glob, where glob is the absolute value of max(globalMax,globalMin).
*/

void normalize_statistics(void)
{
    float globalMax,globalMin,glob;
    int i;

    globalMax=mcubesList[0]->scalarstats->max;
    globalMin=mcubesList[0]->scalarstats->min;

    for (i=1;i<nMeshes;i++) {
        float localMax,localMin; /* for localPeople */
        localMax = mcubesList[i]->scalarstats->max;
        localMin = mcubesList[i]->scalarstats->min;
        if (localMax > globalMax) { globalMax = localMax; }
        if (localMin < globalMin) { globalMin = localMin; }
    }

    if (fabs(globalMax)>fabs(globalMin)) { glob = globalMax; }
    else { glob = globalMin; }
    glob = 0.1* fabs(glob);

    for (i=0;i<nMeshes;i++) {
        mcubesList[i]->scalarstats->max =  glob;
        mcubesList[i]->scalarstats->min = -glob;
    }

}

void render (GLfloat *m, GLfloat *mi) {

        if (colouredFlag) {
            glColorMaterial(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);
        } else {
            glColorMaterial(GL_BACK,GL_AMBIENT_AND_DIFFUSE);
            glColor3fv(innerColour);
            glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
            glColor3fv(outerColour);
        }

        glEnable(GL_LIGHTING);
        if (fogFlag) { glEnable(GL_FOG); }


        if (surfaceFlag) {
            glPushMatrix();
                    glTranslatef(
                            -0.5*mcubesList[currentMeshNo]->nx,
                            -0.5*mcubesList[currentMeshNo]->ny,
                            -0.5*mcubesList[currentMeshNo]->nz
                    );

                    glCallList(getMeshList()+currentMeshNo);

            glPopMatrix();
        }


        glColorMaterial(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);
        glColor4f(0,1,0,0.9);
        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
        glPointSize(5.0);

        glDisable(GL_FOG);
        glDisable(GL_LIGHTING);

            if (axesFlag)      { drawAxes(mi); }
            if (outlineFlag)   { drawOutline(); }
            if (vertexLabelFlag)        { drawVertexLabels(mi); }
            if (triangleLabelFlag)      { drawTriangleLabels(mi); }
            if (debugOverlayFlag)  { drawDebugOverlay(); }

        if (fogFlag) { glEnable(GL_FOG); }

            if (meshOutlineFlag)  { drawMeshOutline(); }
            if (cuberilleFlag)    { drawCuberille(); }

        glEnable(GL_LIGHTING);

        return ;
}

void orient(GLfloat *m, GLfloat *mi,GLfloat dx, GLfloat dy, GLfloat dz)
{




    struct window *w=NULL;

    w = getWindow();
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();


    if (orthoFlag) {
        /* Set orthogonal projection */
        int vnx,vny,vnz;
        GLfloat size;
        vnx = mcubesList[currentMeshNo]->nx;
        vny = mcubesList[currentMeshNo]->ny;
        vnz = mcubesList[currentMeshNo]->nz;
        size=vnx;
        if (vny>size) { size=vny; }
        if (vnz>size) { size=vnz; }
        size*=0.75;
      glOrtho(-size,size,-size,size,nearclip,farclip);
    } else {
      /* Set perspective projection */
      gluPerspective(fov, (float)w->screenx/(float)w->screeny,nearclip,farclip );
    }
    glMatrixMode(GL_MODELVIEW);

    glDepthMask(GL_TRUE);


    /* Position and orient geometry */

    glLoadIdentity();
    glTranslatef(geomx+dx,geomy+dy,geomz+dz);

    quatmatrixandinv(orquat,m,mi);
    glMultMatrixf(m);
}


void draw_gl()
{
        GLfloat m[16],mi[16];
        if (stereoFlag) {
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();

                glDrawBuffer(GL_BACK);
                glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

                glDrawBuffer(GL_BACK_LEFT);
                orient(m,mi,eyeSize,0,0);
                render(m,mi);
                glClear(GL_DEPTH_BUFFER_BIT);
                glDrawBuffer(GL_BACK_RIGHT);
                orient(m,mi,-eyeSize,0,0);
                render(m,mi);

        } else if (windowedStereoFlag) {
                float dir=1;
                if (getWindow()->id == leftWindow.id) {
                    dir = 1;
                } else {
                    dir = -1;
                }
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();

                glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
                orient(m,mi,dir*eyeSize,0,0);
                render(m,mi);
        } else {
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();

                glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
                orient(m,mi,0,0,0);
                render(m,mi);
        }
}


/* This should be called every time the geometry changes. */
void frameChanged(void)
{

}

void redisplayFrame(void)
{
    frameChanged();
    allPostRedisplay();
    if (colVolFlag) {
        printf("Displaying %s coloured by %s\n",
        fileNames[2*currentMeshNo],fileNames[2*currentMeshNo+1]);
    } else if (scalarCurvatureFlag) {
        printf("Displaying %s coloured by curvature\n",
                fileNames[currentMeshNo]);
    } else {
        printf("Displaying %s\n",fileNames[currentMeshNo]);
    }
}

void incrementFrame(void)
{
    currentMeshNo++;
    if (currentMeshNo>=nMeshes) {
        if (wrapMeshNoFlag) {
                 currentMeshNo-=nMeshes; 
        } else { currentMeshNo=nMeshes-1; }
    }

    redisplayFrame();

}

void decrementFrame(void)
{
    currentMeshNo--;
    if (currentMeshNo<0) {
        if (wrapMeshNoFlag) {
                 currentMeshNo=nMeshes-1; 
        } else { currentMeshNo=0; }
    }

    redisplayFrame();
}


/* Process mouse motion from x0,y0 to x1,y1 */

void mouserotatemotion(float x0,float y0, float x1,float y1) {

    GLfloat mx,my,m,s;
    GLfloat theta;
    quat_t rotquat;

    s = getWindow()->sphererad;
    my = (GLfloat)(x1-x0);
    mx = (GLfloat)(y1-y0);
    m=sqrt(mx*mx+my*my);

    if ((m>0) && (m<s)) {
        theta = m/s;

        mx /= m;
        my /= m;

        rotquat = quatrotation(theta,mx,my,0.0);
        orquat = quatmultiply(rotquat,orquat);
    }

}

void mousezoommotion(int dz)
{
    const GLfloat zoomscale=0.1;
    geomz-=zoomscale*dz;
    return;
}

void mousetransmotion(int dx,int dy)
{
    const GLfloat transscale=0.06;
    geomx-=transscale*dx;
    geomy+=transscale*dy;
    return;
}


/* Clear up and quit. */
void quit_all() {

    exit(0);
}

void reshapefunc(int width, int height)
{
    struct window *w=NULL;
    w = getWindow();
    printf("Reshaped to %d x %d\n",width,height);
    glViewport(0,0,width,height);
    w->screenx = width;
    w->screeny = height;
    if (w->screenx<w->screeny) {
        w->sphererad=0.5*w->screeny;
    } else {
        w->sphererad=0.5*w->screenx;
    }
}

long gettime_ms(void)
{
    struct timeval tv;

    gettimeofday(&tv,NULL);

    return 1000*tv.tv_sec + (tv.tv_usec/1000);

}

void displayfunc(void)
{
    struct timeval tStart,tEnd;
    unsigned long frame_us;

    if (timeFrameFlag) { gettimeofday(&tStart,NULL); }

    draw_gl();
    glutSwapBuffers();

    if (timeFrameFlag) {
        gettimeofday(&tEnd,NULL);

        frame_us = 1000000*(tEnd.tv_sec-tStart.tv_sec)
                          +(tEnd.tv_usec-tStart.tv_usec);
        fprintf(stderr,"%lu us rendering time\n",frame_us);fflush(stderr);
    }
}


void mousefunc(int button, int state, int x, int y)
{
    struct window *w=NULL;

    w=getWindow();

    w->clickx = x;
    w->clicky = y;

#define WHEEL_UP 3      /* Experimental measurement.. */
#define WHEEL_DOWN 4

    switch (button) {
        case GLUT_LEFT_BUTTON:
            w->leftState = (GLUT_DOWN == state) ? 1 : 0;
            break;
        case GLUT_MIDDLE_BUTTON:
            w->middleState = (GLUT_DOWN == state) ? 1 : 0;
            break;
        case GLUT_RIGHT_BUTTON:
            w->rightState = (GLUT_DOWN == state) ? 1 : 0;
            break;
        case WHEEL_UP:
            if (state) { incrementFrame(); }
            break;
        case WHEEL_DOWN:
            if (state) { decrementFrame(); }
            break;
    }
}



void motionfunc(int x, int y)
{
    struct window *w=NULL;

    w=getWindow();

    if (w->leftState) {
        mouserotatemotion(w->clickx,w->clicky,x,y);
    } else if (w->middleState) {
        mousetransmotion(w->clickx-x,w->clicky-y);
    } else {
        mousezoommotion(y-w->clicky);
    }
    w->clickx=x;w->clicky=y;
    allPostRedisplay();
}

void timerfunc(int val)
{
    const float omega=0.001047; /* 2pi/60000 ms^-1 */
    float dx,dy;

    mstime += dtime;

    dx = 2.0 * cos(omega*mstime);
    dy = 2.0 * sin(1.1*omega*mstime);

    if (spinFlag) {
        mouserotatemotion(0,0,dx,dy);
        allPostRedisplay();
        glutTimerFunc(dtime,timerfunc,0);
    }
}

void spinOn() {
    mstime=0;
    spinFlag=1;
    glutTimerFunc(dtime,timerfunc,0);
}

void spinOff() {
    spinFlag=0;
}

void dumpOrientation(FILE *f)
{
        fprintf(f,"Orientation quaternion %f %f %f %f\n",
                orquat.q0,
                orquat.q1,
                orquat.q2,
                orquat.q3);
        fprintf(f,"Geom = %f %f %f\n",geomx,geomy,geomz);
        fflush(f);
}



void keyboardfunc(unsigned char key, int x, int y)
{
    struct window *w=NULL;

    w = getWindow();
        switch(key) {
                case 'Q':
                        exit(0);
                case '!':
                        bgColour[0]=1.0-bgColour[0];
                        bgColour[1]=1.0-bgColour[1];
                        bgColour[2]=1.0-bgColour[2];
                        ALL_WINDOWS(
                         glClearColor(bgColour[0],bgColour[1],bgColour[2],0.0);
                        )
                        allPostRedisplay();
                        break;

                case '<':
                        fov--; allPostRedisplay();
                        fprintf(stderr,"FOV=%f degrees\n",fov);fflush(stderr);
                        break;
                case '>':
                        fov++; allPostRedisplay();
                        fprintf(stderr,"FOV=%f degrees\n",fov);fflush(stderr);
                        break;
                case 'd':
                        dumpOrientation(stderr);
                        break;
                case 'i':
                        toggleSurface();
                        break;
                case 'f':
                        toggleFog();
                        break;
                case '[':
                        decreaseFog();
                        break;
                case ']':
                        increaseFog();
                        break;
                case 'a':
                        toggleAxes();
                        break;
                case 'p':
                        toggleOrtho();
                        break;
                case 'o':
                        toggleOutline();
                        break;
                case 'h':
                        toggleSpecular();
                        break;
                case 'm':
                        toggleMeshOutline();
                        break;
                case 'D':
                        toggleDebugOverlay();
                        break;
                case 'c':
                        toggleCuberille();
                        break;
                case 'z':
                        decrementFrame();
                        break;
                case 'x':
                        incrementFrame();
                        break;
                    case 'v':
                        if (debugMode) { toggleVertexLabels(); }
                        break;
                    case 't':
                        if (debugMode) { toggleTriangleLabels(); }
                        break;
                case 's':
                        spinFlag=1-spinFlag;
                        printf("Spinning %s\n",
                                spinFlag ? "on" : "off");
                        if (spinFlag) { spinOn();} else { spinOff(); }
                        break;
                case 'w':
                        wrapMeshNoFlag=1-wrapMeshNoFlag;
                        printf("Wrapping %s\n",
                                wrapMeshNoFlag ? "on" : "off");
                        break;
                case '/':
                        eyeSize *= 1.1;
                        fprintf(stderr,"eyeSize %f\n",eyeSize);
                        allPostRedisplay();
                        break;
                case '\\':
                        eyeSize /= 1.1;
                        fprintf(stderr,"eyeSize %f\n",eyeSize);
                        allPostRedisplay();
                        break;
                case 'S': /* Screenshot */
                fprintf(stderr,"caught screenshot\n");fflush(stderr);
                    gl_screenshot_png(w->screenx,w->screeny,"screenshot.png",1);
                    fprintf(stderr,"Saved screenshot.png\n"); fflush(stderr);
                    break;
        }
}

int imax(int a,int b){ return ( a > b ) ? a : b ; }


void render_mesh(int i,
        void (*colMapFunc)(float,struct vol3df_stats *,GLfloat *)) {

    if (windowedStereoFlag) {
        GLuint currID;

        currID = glutGetWindow();
        glutSetWindow(leftWindow.id);
            glNewList(leftWindow.meshList+i,GL_COMPILE);
            fprintf(stderr,"Rendering left...");fflush(stderr);
                mcubes_draw(mcubesList[i],colMapFunc);
            fprintf(stderr," done.\n");fflush(stderr);
            fprintf(stderr,"Compiling left display list...");fflush(stderr);
            glEndList();
            fprintf(stderr," done.\n");fflush(stderr);
        glutSetWindow(rightWindow.id);
            glNewList(rightWindow.meshList+i,GL_COMPILE);
            fprintf(stderr,"Rendering right...");fflush(stderr);
                mcubes_draw(mcubesList[i],colMapFunc);
            fprintf(stderr," done.\n");fflush(stderr);
            fprintf(stderr,"Compiling right display list...");fflush(stderr);
            glEndList();
            fprintf(stderr," done.\n");fflush(stderr);

        glutSetWindow(currID);

    } else {
        glNewList(window.meshList+i,GL_COMPILE);
        fprintf(stderr,"Rendering...");fflush(stderr);
            mcubes_draw(mcubesList[i],colMapFunc);
        fprintf(stderr," done.\n");fflush(stderr);
        fprintf(stderr,"Compiling display list...");fflush(stderr);
        glEndList();
        fprintf(stderr," done.\n");fflush(stderr);
    }


    fprintf(stderr,"Created surface from %s\n",
            fileNames[i]);fflush(stderr);

    fprintf(stderr,"Cleaning up...");fflush(stderr);
    mcubes_purge_cache(mcubesList[i]);
    mcubes_purge_input_data(mcubesList[i]); /* destroys v as well */
    if (!debugMode) {
            mcubes_purge_geometry(mcubesList[i]);
    }
    fprintf(stderr," done.\n");fflush(stderr);
        /* mcubesList[i] now just holds the geometry metadata */
        /* (if we're in debug mode, it holds the geometry data as well */
}

/* Render the geometry from a vol3d object, which is then destroyed.
 * Does not take account of colvols.
 */
int createGeomFromVol(struct vol3d *v,float threshold,int i,
    void (*colMapFunc)(float,struct vol3df_stats *,GLfloat *) 
        )
{

    if (NULL==(mcubesList[i]
                =mcubes_new(v,threshold,NULL,vNormalsFlag))) {
       fprintf(stderr,
       "Failed to initialize Marching Cubes.\n");
       return -1;
    }

    if (scalarCurvatureFlag) {
        mcubes_scalar_curvature(mcubesList[i]);
        if (gaussianCurvatureFlag) {
            mcubes_gaussian_curvature(mcubesList[i]);
        }
    }


    fprintf(stderr,"Calculating intersections...");
    if (0!=mcubes_calc_vertices(mcubesList[i])) {
        fprintf(stderr,"mcubes_calc_vertices failed.\n");
        return -1;
    }
    fprintf(stderr," done.\n");


    fprintf(stderr,"Triangulating...");fflush(stderr);
    mcubes_lewiner(mcubesList[i]);
    fprintf(stderr," done.\n");fflush(stderr);
    mcubes_info(mcubesList[i],stderr);

    render_mesh(i,globalColMapFunc);
    return 0;
}

/* If loadNewestFlag is set, this function is called every
 * checkFilesInterval milliseconds, to check if a new file has appeared,
 * and if so, to load it.
 */
void timerFunc(int value)
{
    char *newestFilename=NULL;

    struct vol3df_file_hints fileHints = vol3df_default_file_hints;
    struct vol3d *v=NULL;
    struct stat statbuf;

    fprintf(stderr,"Scanning..\n");fflush(stderr);
    glutTimerFunc(checkFilesInterval,timerFunc,0);

    if (NULL==(newestFilename=findRipeFile(newestPrefix,newestTime,minAge)))
        { return; } /* Nothing found. */ 

    /* Update mtime */

    if (0!=stat(newestFilename,&statbuf)) { perror("stat"); return ; }
    newestTime = statbuf.st_mtime;
    fprintf(stderr,"Newest file is %s\n",newestFilename);

    /* Attempt to load it */       

    fileHints.filename = newestFilename;
    if (NULL==(v=vol3df_new_from_file_heuristic(
        fileHints.filename,&fileHints))) {
        fprintf(stderr,"Failed to load \"%s\".\n",newestFilename);
        return ; /* oh well, doesn't matter. */
    }
    fprintf(stderr,"Loaded %dx%dx%d voxels from %s\n",
            v->nx,v->ny,v->nz,fileHints.filename);
    fflush(stderr);

    mcubes_destroy(mcubesList[0]);
    if (0!=createGeomFromVol(v,globalThreshold,0,globalColMapFunc))
            { fprintf(stderr,"Unable to generate geometry\n"); exit(-1); }

    /* Free old "current" filename ; install new one. */
    free(fileNames[0]);
    fileNames[0] = newestFilename;

    allPostRedisplay();
}

void setCallbacks (void)
{
        glutDisplayFunc(displayfunc);
        glutReshapeFunc(reshapefunc);
        glutMouseFunc(mousefunc);
        glutMotionFunc(motionfunc);
        glutKeyboardFunc(keyboardfunc);
}

/* Reset the state of a window structure */
void windowInit (struct window *w)
{
    w->id=w->screenx=w->screeny=w->clickx=w->clicky=0;
    w->sphererad=0.0;
    w->clickx=w->clicky=w->leftState=w->middleState=w->rightState=0;
    w->meshList=0;
    w->mousex=w->mousey=0;
    w->leftbutdown=w->rightbutdown=w->midbutdown=w->bx=w->by=0;
}

int main(int argc, char *argv[])
{

    struct vol3d *v=NULL;
    int i,c;
    const char *optstring="gsnt:Dd:f:b:mi:o:N:cCTzS:wx:";
    struct vol3df_file_hints fileHints = vol3df_default_file_hints;
    enum vol3df_filetype itype = VOL3DF_FTYPE_UNKNOWN;
    int fileNameNo=0;
    int nFiles=-1;
    int screenx=500,screeny=500;
    GLfloat sphererad;


    sphererad = screenx/2;

    while (-1!=(c=getopt(argc,argv,optstring))) {
        switch(c) { 
            case 'N':
                loadNewestFlag=1;
                newestPrefix=optarg;
                break;
            case 'z':
                normalizeScalarFlag=1;
                break;
            case 'T':
                timeFrameFlag=1;
                break;
            case 'C':
                scalarCurvatureFlag=1;
                colouredFlag=1;
                globalColMapFunc = hueColourMap;
                break;
            case 'n':
                vNormalsFlag=0;
                break;
            case 'S':
                globalColScale=atof(optarg);
                break;
            case 's':
                stereoFlag=1;
                break;
            case 'w':
                windowedStereoFlag=1;
                break;
            case 'b':
                {
                    float red,grn,blu;
                    vol3d_parse_floats_string( &red,&grn,&blu,optarg);
                    bgColour[0] = (GLclampf) red;
                    bgColour[1] = (GLclampf) grn;
                    bgColour[2] = (GLclampf) blu;
                    fprintf(stderr,"foo %f %f %f\n",red,grn,blu);
                    fflush(stderr);
                }
                break;
            case 'c':
                colVolFlag=1;
                colouredFlag=1;
                globalColMapFunc = cubicColourMap;
                break;
            case 'g':
                gaussianCurvatureFlag = 1;
                break;
            case 'D':
                fprintf(stderr,"Debug mode enabled.\n");
                debugMode=1;
                break;
            case 'x':
                rightWindowOffset = atoi(optarg);
                break;

            case 'i':
                {
                    float red,grn,blu;
                    vol3d_parse_floats_string( &red,&grn,&blu,optarg);
                    innerColour[0] = (GLfloat) red;
                    innerColour[1] = (GLfloat) grn;
                    innerColour[2] = (GLfloat) blu;
                }
                break;

            case 'o':
                {
                    float red,grn,blu;
                    vol3d_parse_floats_string( &red,&grn,&blu,optarg);
                    outerColour[0] = (GLfloat) red;
                    outerColour[1] = (GLfloat) grn;
                    outerColour[2] = (GLfloat) blu;
                }
                break;

            case 't':
                globalThreshold=atof(optarg);
                break;
            case 'd':
                vol3d_parse_dims_string(
                                        &fileHints.nx,
                                        &fileHints.ny,
                                        &fileHints.nz,
                                        optarg);
                break;
            case 'f':
                itype = vol3df_parse_ftype(optarg);
                if (
                       (VOL3DF_FTYPE_RAW  != itype)
                    && (VOL3DF_FTYPE_XDR  != itype)
                    && (VOL3DF_FTYPE_HDF5 != itype)
                ) {
                    fprintf(stderr,
                          "Unsupported input file type\n");
                    return -1;
                }
                fileHints.type = itype;
                break;
            default:
                return -1;
        } /* switch(c) */
    } /* while (getopt()) */

    if (colVolFlag && scalarCurvatureFlag) {
        fprintf(stderr,"Cannot have curvature colouring and scalar colouring!\n");
        exit(-1);
    }


    if (loadNewestFlag) {
        if (colVolFlag) {
            fprintf(stderr,"Cannot load newest and colour by scalar.\n");
            exit(-1);
        }
        nMeshes=1;
        if (NULL==(fileNames=malloc(sizeof(char *))))
            { perror("malloc"); return -1; }
        fileNames[0]=NULL;
        currentMeshNo=0;
    } else {
        if (argc==optind) {
            fprintf(stderr,"Usage: %s [-f <filetype>]"
                    " [-d <nx>,<ny>,<nz>]"
                    " <file1> [ <file2> [ .. ]]\n",argv[0]);
            return -1;
        }
        fileNames = argv + optind;

        nMeshes = argc-optind;
        nFiles = argc - optind;

        /* The colvol flag means that the filenames are pairs. The first
         * of each pair supplies the geometry; the second supplies the
         * isosurface colour.
         */
        if (colVolFlag) {
            if (0!=(nFiles%2)) {
                fprintf(stderr,
              "Must supply an even number of files in colour-pair mode\n");
                return -1;

            }
            nMeshes = nFiles/2;
        } else {
            nMeshes = nFiles;
        }
    }


    /* Initialize GLUT */

    glutInit(&argc,argv);
    glutInitWindowSize(screenx,screeny);
    glutInitWindowPosition(winPosX,winPosY);

    if (stereoFlag) {
        glutInitDisplayMode(GLUT_RGBA|GLUT_ALPHA|GLUT_DOUBLE|GLUT_DEPTH|GLUT_STEREO);
        fprintf(stderr,"Initialized with GLUT_STEREO\n");
    } else {
        glutInitDisplayMode(GLUT_RGBA|GLUT_DOUBLE|GLUT_DEPTH);
    }

    if (!windowedStereoFlag) {
        windowInit(&window);
        window.id = glutCreateWindow("Terror Gyroid");
        window.screenx = screenx;
        window.screeny = screeny;
        window.sphererad = sphererad;

        initGL();
        glViewport(0,0,screenx,screeny);
        setCallbacks();

    } else {
        windowInit(&leftWindow);
        windowInit(&rightWindow);

        /* Create two windows, and set callbacks accordingly */

        leftWindow.id = glutCreateWindow("Left");

        initGL();
        glViewport(0,0,screenx,screeny);
        setCallbacks();

        glutInitWindowPosition(winPosX+rightWindowOffset,winPosY);
        rightWindow.id = glutCreateWindow("Right");

        initGL();
        glViewport(0,0,screenx,screeny);
        setCallbacks();
    }


    if (windowedStereoFlag) {

        glutSetWindow(leftWindow.id);
        if (0==(leftWindow.meshList=glGenLists(nMeshes))) {
            fprintf(stderr,"Out of display lists!\n");
            exit(-1);
        }

        glutSetWindow(rightWindow.id);
        if (0==(rightWindow.meshList=glGenLists(nMeshes))) {
            fprintf(stderr,"Out of display lists!\n");
            exit(-1);
        }

    } else {
        if (0==(window.meshList=glGenLists(nMeshes))) {
            fprintf(stderr,"Out of display lists!\n");
            exit(-1);
        }
    }

    /* Allocate mcubes array */

    if (NULL==(mcubesList=malloc(sizeof(struct mcubes_state *)*nMeshes)))
        { perror("malloc"); return -1; }

    for (i=0;i<nMeshes;i++) { mcubesList[i]=NULL; }


    if (loadNewestFlag) {

        char *newestFilename=NULL;
        struct stat statbuf;

        /* Load the newest file */

        newestTime=0;
        currentMeshNo=0;

        /* Wait for a file.. */

        fprintf(stderr,"Waiting for a file to appear...\n");fflush(stderr);
        while (NULL==(
                newestFilename=findRipeFile(newestPrefix,newestTime,minAge))) {
            sleep(1);
        }
        if (0!=stat(newestFilename,&statbuf)) { perror("stat"); return -1; }
        newestTime = statbuf.st_mtime;
        fprintf(stderr,"Newest file is %s\n",newestFilename);
        fileHints.filename = newestFilename;

        if (NULL==(v=vol3df_new_from_file_heuristic(
            fileHints.filename,&fileHints))) {
            fprintf(stderr,"Failed to load \"%s\".\n",newestFilename);
            return -1;
        }
        fprintf(stderr,"Loaded %dx%dx%d voxels from %s\n",
                v->nx,v->ny,v->nz,fileHints.filename);
        fflush(stderr);

        if (0!=createGeomFromVol(v,globalThreshold,0,globalColMapFunc))
                { fprintf(stderr,"Unable to generate geometry\n"); exit(-1); }

        /* Set up callback */

        glutTimerFunc(checkFilesInterval,timerFunc,0);
        fileNames[0]=newestFilename;

    } else {
        /* Load each file in turn, generate a mesh from it, and
         * hand the geometry to GL.
         */
        for (i=0;i<nMeshes;i++) {
            struct vol3d *colVol=NULL;

            fileHints.filename = fileNames[fileNameNo++];
            if (NULL==(v=vol3df_new_from_file_heuristic(
                fileHints.filename,&fileHints))) {
                fprintf(stderr,"Failed to load \"%s\".\n",fileHints.filename);
                return -1;
            }

            fprintf(stderr,"Loaded %dx%dx%d voxels from %s\n",
                    v->nx,v->ny,v->nz,fileHints.filename);
            fflush(stderr);

            if (colVolFlag) { /* Load a surface colour field as well. */

                fileHints.filename = fileNames[fileNameNo++];

                if (NULL==(colVol=vol3df_new_from_file_heuristic(
                    fileHints.filename,&fileHints))) {
                    fprintf(stderr,"Failed to load colour \"%s\".\n",
                            fileHints.filename);
                    return -1;
                }
                if (NULL==(mcubesList[i]
                            =mcubes_new(v,globalThreshold,colVol,vNormalsFlag))) {
                   fprintf(stderr,
                   "Failed to initialize Marching Cubes.\n");
                   return -1;
                }
            } else {
                if (NULL==(mcubesList[i]
                            =mcubes_new(v,globalThreshold,NULL,vNormalsFlag))) {
                   fprintf(stderr,
                   "Failed to initialize Marching Cubes.\n");
                   return -1;
                }
            }

            if (scalarCurvatureFlag) {
                mcubes_scalar_curvature(mcubesList[i]);
                if (gaussianCurvatureFlag) {
                    mcubes_gaussian_curvature(mcubesList[i]);
                }
            }


            fprintf(stderr,"Calculating intersections...");
            if (0!=mcubes_calc_vertices(mcubesList[i])) {
                fprintf(stderr,"mcubes_calc_vertices failed.\n");
                return -1;
            }
            fprintf(stderr," done.\n");


            fprintf(stderr,"Triangulating...");fflush(stderr);
            mcubes_lewiner(mcubesList[i]);
            fprintf(stderr," done.\n");fflush(stderr);
            mcubes_info(mcubesList[i],stderr);

            if (!normalizeScalarFlag) {
                render_mesh(i,globalColMapFunc);
            } else {
                /* Locally centre distribution */
                float maxmag,max,min;
                printf("foo!\n");fflush(stdout);
                max = mcubesList[i]->scalarstats->max;
                min = mcubesList[i]->scalarstats->min;
                if (fabs(max)>fabs(min)) {
                    maxmag = fabs(max);
                } else {
                    maxmag = fabs(min);
                }
                mcubesList[i]->scalarstats->max =  maxmag;
                mcubesList[i]->scalarstats->min = -maxmag;
            }


        } /* loop over mesh i */

        if (normalizeScalarFlag) {
            normalize_statistics();
            for (i=0;i<nMeshes;i++) {
                render_mesh(i,globalColMapFunc);
            }
        }
    }


    {
        quat_t xq,yq;
        xq = quatrotation(M_PI*0.25,1.0,0.0,0.0);
        yq = quatrotation(asin(1.0/sqrt(3.0)),0.0,1.0,0.0);
        orquat = quatmultiply(yq,xq);

    }

    /* Main loop */

    fprintf(stderr,"Entering main loop.\n");
    glutMainLoop();

    return 0;
}       

